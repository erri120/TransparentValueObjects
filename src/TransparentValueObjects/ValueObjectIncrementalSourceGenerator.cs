using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TransparentValueObjects;

[Generator]
public class ValueObjectIncrementalSourceGenerator : IIncrementalGenerator
{
    private const string GeneratedNamespace = "TransparentValueObjects.Generated";
    private const string AttributeClassName = "ValueObjectAttribute";

    private const string AugmentedNamespace = "TransparentValueObjects.Augments";
    private const string ValueObjectInterfaceName = "IValueObject";
    private const string HasDefaultValueInterfaceName = "IHasDefaultValue";
    private const string HasDefaultEqualityComparerInterfaceName = "IHasDefaultEqualityComparer";
    private const string HasSystemTextJsonConverterInterfaceName = "IHasSystemTextJsonConverter";
    private const string HasEfCoreInterfaceName = "IHasEfCore";

    private const string AttributeSourceCode =
$$"""
// <auto-generated/>

namespace {{GeneratedNamespace}}
{
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = "Auto-generated")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Struct)]
    public class {{AttributeClassName}}<T> : global::System.Attribute { }
}
""";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{AttributeClassName}.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8))
        );

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                Predicate,
                Transform
            )
            .Where(t => !t.Equals(default));

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            static (ctx, tuple) => Generate(ctx, tuple.Left, tuple.Right)
        );
    }

    private static bool Predicate(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        return syntaxNode is StructDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static Target Transform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var syntaxNode = (StructDeclarationSyntax) context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(syntaxNode, cancellationToken);

        if (symbol is null) return default;

        var attributes = symbol.GetAttributes();
        if (attributes.Length == 0) return default;

        var attributeData = attributes.FirstOrDefault(static a => string.Equals(a?.AttributeClass?.Name, $"{AttributeClassName}", StringComparison.Ordinal));
        if (attributeData is null) return default;

        return new Target(syntaxNode, attributeData);
    }

    private static void Generate(SourceProductionContext context, Compilation compilation, ImmutableArray<Target> targets)
    {
        if (compilation.GetTypeByMetadataName(typeof(Type).FullName!) is not { } typeSymbol) return;

        foreach (var target in targets)
        {
            var valueObjectDeclarationSyntax = target.Syntax;
            var attributeData = target.AttributeData;

            var semanticModel = compilation.GetSemanticModel(valueObjectDeclarationSyntax.SyntaxTree);
            var valueObjectTypeSymbol = semanticModel.GetDeclaredSymbol(valueObjectDeclarationSyntax, cancellationToken: context.CancellationToken);

            if (valueObjectTypeSymbol is not INamedTypeSymbol valueObjectNamedTypeSymbol) continue;

            var namespaceName = valueObjectNamedTypeSymbol.ContainingNamespace.ToDisplayString();
            var valueObjectTypeName = valueObjectNamedTypeSymbol.Name;

            var innerValueTypeSymbol = attributeData.AttributeClass?.TypeArguments.FirstOrDefault();
            if (innerValueTypeSymbol is not INamedTypeSymbol innerValueNamedTypeSymbol) continue;

            var innerValueTypeName = innerValueNamedTypeSymbol.ToDisplayString(CustomSymbolDisplayFormats.GlobalFormat);
            var innerValueTypeNullableAnnotation = innerValueNamedTypeSymbol.IsReferenceType ? "?" : "";

            var innerValueInterfaces = innerValueNamedTypeSymbol.Interfaces;
            var valueObjectInterfaces = valueObjectNamedTypeSymbol.Interfaces;

            var hasSystemTextJsonConverter = HasAugment(valueObjectInterfaces, HasSystemTextJsonConverterInterfaceName);
            var hasSystemTextJsonConverterOverride = valueObjectNamedTypeSymbol.GetMembers("SystemTextJsonConverterType")
                .Any(x => x is IPropertySymbol { Type: var ret } && SymbolEqualityComparer.Default.Equals(ret, typeSymbol));

            var hasEfCore = HasAugment(valueObjectInterfaces, HasEfCoreInterfaceName);

            var cw = new CodeWriter();

            // header, namespace and type definition
            cw.AppendLine("// <auto-generated/>");
            cw.AppendLine("#nullable enable");
            cw.AppendLine($"namespace {namespaceName};");
            cw.AppendLine();

            cw.AppendLine("[global::System.Diagnostics.DebuggerDisplay(\"{Value}\")]");
            cw.AppendLine("[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = \"Auto-generated.\")]");

            // TODO: use override
            if (hasSystemTextJsonConverter)
                cw.AppendLine("[global::System.Text.Json.Serialization.JsonConverter(typeof(SystemTextJsonConverter))]");

            cw.AppendLine($"readonly partial struct {valueObjectTypeName} :");

            // interfaces
            cw.AppendLine($"\tglobal::{AugmentedNamespace}.{ValueObjectInterfaceName}<{innerValueTypeName}>,");
            cw.AppendLine($"\tglobal::System.IEquatable<{valueObjectTypeName}>,");
            cw.Append($"\tglobal::System.IEquatable<{innerValueTypeName}>");

            var comparableInterfaceTypeSymbol = GetInterfaceWithInnerTypeArgument(innerValueInterfaces, innerValueTypeSymbol, typeof(IComparable<>));
            if (comparableInterfaceTypeSymbol is not null)
            {
                cw.AppendLine(",");
                cw.Append($"\tglobal::System.IComparable<{valueObjectTypeName}>");
            }

            cw.AppendLine();

            using (cw.AddBlock())
            {
                // backing field
                cw.AppendLine($"public readonly {innerValueTypeName} Value;");
                cw.AppendLine();

                // IValueObject implementation
                cw.AppendLine($"public static global::System.Type InnerValueType => typeof({innerValueTypeName});");
                cw.AppendLine();

                // public default constructor
                var hasDefaultValue = HasAugment(valueObjectInterfaces, HasDefaultValueInterfaceName);
                AddPublicConstructor(cw, valueObjectTypeName, hasDefaultValue);

                // private constructor with value
                AddPrivateConstructor(cw, valueObjectTypeName, innerValueTypeName);

                // public From method
                cw.AppendLine($"public static {valueObjectTypeName} From({innerValueTypeName} value) => new(value);");
                cw.AppendLine();

                // ToString and GetHashCode
                OverrideBaseMethods(cw);

                // Equals methods from interfaces and base object
                var hasDefaultEqualityComparer = HasAugment(valueObjectInterfaces, HasDefaultEqualityComparerInterfaceName);
                ImplementEqualsMethods(cw, valueObjectTypeName, innerValueTypeName, innerValueTypeNullableAnnotation, hasDefaultEqualityComparer);

                // equality operators
                AddEqualityOperators(cw, valueObjectTypeName, innerValueTypeName);

                // explicit cast operators
                AddExplicitCastOperators(cw, valueObjectTypeName, innerValueTypeName);

                // System.Text.Json
                if (hasSystemTextJsonConverter && !hasSystemTextJsonConverterOverride)
                    AddSystemTextJsonClasses(cw, valueObjectTypeName, innerValueTypeName, hasDefaultValue);

                // EF Core
                if (hasEfCore)
                    AddEfCoreClasses(cw, valueObjectTypeName, innerValueTypeName);

                if (comparableInterfaceTypeSymbol is not null)
                {
                    ForwardInterface(cw, valueObjectTypeName, comparableInterfaceTypeSymbol);
                    AddComparisonOperators(cw, valueObjectTypeName, innerValueTypeName);
                }

                if (string.Equals(innerValueTypeName, "global::System.Guid", StringComparison.Ordinal))
                    AddGuidSpecificCode(cw, valueObjectTypeName, innerValueTypeName);
            }

            if (hasEfCore)
                AddEfCoreExtensions(cw, valueObjectTypeName, SyntaxFacts.GetText(valueObjectTypeSymbol.DeclaredAccessibility));

            context.AddSource($"{valueObjectTypeName}.g.cs", SourceText.From(cw.ToString(), Encoding.UTF8));
        }
    }

    private static INamedTypeSymbol? GetInterfaceWithInnerTypeArgument(
        ImmutableArray<INamedTypeSymbol> interfaces,
        ISymbol innerValueTypeSymbol,
        Type interfaceType)
    {
        var typeNameWithoutType = interfaceType.Name.Substring(0, interfaceType.Name.IndexOf('`'));
        return interfaces.FirstOrDefault(
            namedSymbol => string.Equals(namedSymbol.ContainingNamespace.Name, interfaceType.Namespace, StringComparison.Ordinal) &&
                           string.Equals(namedSymbol.Name, typeNameWithoutType, StringComparison.Ordinal) && namedSymbol.TypeArguments.Length == 1 &&
                           string.Equals(namedSymbol.TypeArguments[0].Name, innerValueTypeSymbol.Name, StringComparison.Ordinal)
        );
    }

    private static bool HasAugment(ImmutableArray<INamedTypeSymbol> existingInterfaces, string augmentName)
    {
        return existingInterfaces.Any(x =>
            string.Equals(x.Name, augmentName, StringComparison.Ordinal) &&
            string.Equals(x.ContainingNamespace.ToDisplayString(), AugmentedNamespace, StringComparison.Ordinal)
        );
    }

    public static void AddPublicConstructor(CodeWriter cw, string valueObjectTypeName, bool hasDefaultValue)
    {
        if (hasDefaultValue)
        {
            cw.AppendLine($"public {valueObjectTypeName}()");
            using (cw.AddBlock())
            {
                cw.AppendLine("Value = DefaultValue.Value;");
            }
        }
        else
        {
            cw.AppendLine($"[global::System.Obsolete($\"Use {valueObjectTypeName}.{{nameof(From)}} instead.\", error: true)]");
            cw.AppendLine($"public {valueObjectTypeName}()");

            using (cw.AddBlock())
            {
                cw.AppendLine($"throw new global::System.InvalidOperationException($\"Use {valueObjectTypeName}.{{nameof(From)}} instead.\");");
            }
        }
    }

    public static void AddPrivateConstructor(CodeWriter cw, string valueObjectTypeName, string innerValueTypeName)
    {
        cw.AppendLine($"private {valueObjectTypeName}({innerValueTypeName} value)");
        using (cw.AddBlock())
        {
            cw.AppendLine("Value = value;");
        }
    }

    public static void OverrideBaseMethods(CodeWriter cw)
    {
        // hash code
        cw.AppendLine("public override int GetHashCode() => Value.GetHashCode();");
        cw.AppendLine();

        // ToString
        cw.AppendLine("public override string ToString() => Value.ToString();");
        cw.AppendLine();
    }

    public static void ImplementEqualsMethods(
        CodeWriter cw,
        string valueObjectTypeName,
        string innerValueTypeName,
        string innerValueTypeNullableAnnotation,
        bool hasDefaultEqualityComparer)
    {
        // IEquality<Self>
        cw.AppendLine($"public bool Equals({valueObjectTypeName} other) => Equals(other.Value);");

        // IEquality<Value>
        if (hasDefaultEqualityComparer)
        {
            cw.AppendLine($"public bool Equals({innerValueTypeName}{innerValueTypeNullableAnnotation} other) => InnerValueDefaultEqualityComparer.Equals(Value, other);");
        }
        else
        {
            cw.AppendLine($"public bool Equals({innerValueTypeName}{innerValueTypeNullableAnnotation} other) => Value.Equals(other);");
        }

        // with equality comparer
        cw.AppendLine($"public bool Equals({valueObjectTypeName} other, global::System.Collections.Generic.IEqualityComparer<{innerValueTypeName}> comparer) => comparer.Equals(Value, other.Value);");

        // object.Equals
        cw.AppendLine("public override bool Equals(object? obj)");
        using (cw.AddBlock())
        {
            cw.AppendLine("if (obj is null) return false;");
            cw.AppendLine($"if (obj is {valueObjectTypeName} value) return Equals(value);");
            cw.AppendLine($"if (obj is {innerValueTypeName} innerValue) return Equals(innerValue);");
            cw.AppendLine("return false;");
        }
    }

    public static void AddEqualityOperators(
        CodeWriter cw,
        string valueObjectTypeName,
        string innerValueTypeName)
    {
        cw.AppendLine($"public static bool operator ==({valueObjectTypeName} left, {valueObjectTypeName} right) => left.Equals(right);");
        cw.AppendLine($"public static bool operator !=({valueObjectTypeName} left, {valueObjectTypeName} right) => !left.Equals(right);");
        cw.AppendLine();

        cw.AppendLine($"public static bool operator ==({valueObjectTypeName} left, {innerValueTypeName} right) => left.Equals(right);");
        cw.AppendLine($"public static bool operator !=({valueObjectTypeName} left, {innerValueTypeName} right) => !left.Equals(right);");
        cw.AppendLine();

        cw.AppendLine($"public static bool operator ==({innerValueTypeName} left, {valueObjectTypeName} right) => right.Equals(left);");
        cw.AppendLine($"public static bool operator !=({innerValueTypeName} left, {valueObjectTypeName} right) => !right.Equals(left);");
        cw.AppendLine();
    }

    public static void AddExplicitCastOperators(
        CodeWriter cw,
        string valueObjectTypeName,
        string innerValueTypeName)
    {
        cw.AppendLine($"public static explicit operator {valueObjectTypeName}({innerValueTypeName} value) => From(value);");
        cw.AppendLine($"public static explicit operator {innerValueTypeName}({valueObjectTypeName} value) => value.Value;");
        cw.AppendLine();
    }

    public static void AddComparisonOperators(
        CodeWriter cw,
        string valueObjectTypeName,
        string innerValueTypeName)
    {
        cw.AppendLine($"public static bool operator <({valueObjectTypeName} left, {valueObjectTypeName} right) => left.Value.CompareTo(right.Value) < 0;");
        cw.AppendLine($"public static bool operator >({valueObjectTypeName} left, {valueObjectTypeName} right) => left.Value.CompareTo(right.Value) > 0;");
        cw.AppendLine($"public static bool operator <=({valueObjectTypeName} left, {valueObjectTypeName} right) => left.Value.CompareTo(right.Value) <= 0;");
        cw.AppendLine($"public static bool operator >=({valueObjectTypeName} left, {valueObjectTypeName} right) => left.Value.CompareTo(right.Value) >= 0;");
        cw.AppendLine();

        cw.AppendLine($"public static bool operator <({innerValueTypeName} left, {valueObjectTypeName} right) => left.CompareTo(right.Value) < 0;");
        cw.AppendLine($"public static bool operator >({innerValueTypeName} left, {valueObjectTypeName} right) => left.CompareTo(right.Value) > 0;");
        cw.AppendLine($"public static bool operator <=({innerValueTypeName} left, {valueObjectTypeName} right) => left.CompareTo(right.Value) <= 0;");
        cw.AppendLine($"public static bool operator >=({innerValueTypeName} left, {valueObjectTypeName} right) => left.CompareTo(right.Value) >= 0;");
        cw.AppendLine();

        cw.AppendLine($"public static bool operator <({valueObjectTypeName} left, {innerValueTypeName} right) => left.Value.CompareTo(right) < 0;");
        cw.AppendLine($"public static bool operator >({valueObjectTypeName} left, {innerValueTypeName} right) => left.Value.CompareTo(right) > 0;");
        cw.AppendLine($"public static bool operator <=({valueObjectTypeName} left, {innerValueTypeName} right) => left.Value.CompareTo(right) <= 0;");
        cw.AppendLine($"public static bool operator >=({valueObjectTypeName} left, {innerValueTypeName} right) => left.Value.CompareTo(right) >= 0;");
        cw.AppendLine();
    }

    private static void ForwardInterface(
        CodeWriter cw,
        string valueObjectTypeName,
        INamedTypeSymbol interfaceNamedTypeSymbol)
    {
        foreach (var memberSymbol in interfaceNamedTypeSymbol.GetMembers())
        {
            if (memberSymbol is not IMethodSymbol methodSymbol) continue;
            var originalSymbol = methodSymbol.OriginalDefinition;

            cw.Append("public ");
            cw.Append(originalSymbol.ReturnsVoid ? "void " : $"{TypeSymbolToString(originalSymbol.ReturnType)} ");
            cw.Append(originalSymbol.Name);

            cw.Append("(");

            var first = true;
            foreach (var parameterSymbol in originalSymbol.Parameters)
            {
                if (!first) cw.Append(", ");
                first = false;

                cw.Append($"{TypeSymbolToString(parameterSymbol.Type)} ");
                cw.Append(parameterSymbol.Name);
            }

            cw.Append($") => Value.{originalSymbol.Name}(");

            first = true;
            foreach (var parameterSymbol in originalSymbol.Parameters)
            {
                if (!first) cw.Append(", ");
                first = false;

                cw.Append(parameterSymbol.Name);
            }

            cw.Append(");");
            cw.AppendLine();
        }

        return;
        string TypeSymbolToString(ITypeSymbol typeSymbol)
        {
            return typeSymbol.TypeKind == TypeKind.TypeParameter
                ? valueObjectTypeName
                : typeSymbol.ToDisplayString(CustomSymbolDisplayFormats.GlobalFormat);
        }
    }

    public static void AddGuidSpecificCode(
        CodeWriter cw,
        string valueObjectTypeName,
        string innerValueTypeName)
    {
        cw.AppendLine($"public static {valueObjectTypeName} NewId() => From({innerValueTypeName}.NewGuid());");
        cw.AppendLine();
    }

    public static void AddSystemTextJsonClasses(CodeWriter cw, string valueObjectTypeName, string innerValueTypeName, bool hasDefaultValue)
    {
        cw.AppendLine("public static global::System.Type SystemTextJsonConverterType => typeof(SystemTextJsonConverter);");

        cw.AppendLine($"public class SystemTextJsonConverter : global::System.Text.Json.Serialization.JsonConverter<{valueObjectTypeName}>");
        using (cw.AddBlock())
        {
            cw.AppendLine($"private static global::System.Text.Json.Serialization.JsonConverter<{innerValueTypeName}> GetInnerValueConverter(global::System.Text.Json.JsonSerializerOptions options)");
            using (cw.AddBlock())
            {
                cw.AppendLine($"var innerValueConverter = options.GetConverter(typeof({innerValueTypeName}));");
                cw.AppendLine($"if (innerValueConverter is null) throw new global::System.Text.Json.JsonException($\"Unable to find converter for type {{typeof({innerValueTypeName})}}\");");
                cw.AppendLine($"return (global::System.Text.Json.Serialization.JsonConverter<{innerValueTypeName}>) innerValueConverter;");
            }

            cw.AppendLine($"public override {valueObjectTypeName} Read(ref global::System.Text.Json.Utf8JsonReader reader, global::System.Type typeToConvert, global::System.Text.Json.JsonSerializerOptions options)");
            using (cw.AddBlock())
            {
                cw.AppendLine("var innerValueConverter = GetInnerValueConverter(options);");
                cw.AppendLine($"var innerValue = innerValueConverter.Read(ref reader, typeof({innerValueTypeName}), options);");
                cw.AppendLine($"return innerValue == default ? {(hasDefaultValue ? "DefaultValue" : $"default({innerValueTypeName})")} : From(innerValue);");
            }

            cw.AppendLine($"public override void Write(global::System.Text.Json.Utf8JsonWriter writer, {valueObjectTypeName} value, global::System.Text.Json.JsonSerializerOptions options)");
            using (cw.AddBlock())
            {
                cw.AppendLine("var innerValueConverter = GetInnerValueConverter(options);");
                cw.AppendLine("innerValueConverter.Write(writer, value.Value, options);");
            }

            cw.AppendLine($"public override {valueObjectTypeName} ReadAsPropertyName(ref global::System.Text.Json.Utf8JsonReader reader, global::System.Type typeToConvert, global::System.Text.Json.JsonSerializerOptions options)");
            using (cw.AddBlock())
            {
                cw.AppendLine("var innerValueConverter = GetInnerValueConverter(options);");
                cw.AppendLine($"var innerValue = innerValueConverter.ReadAsPropertyName(ref reader, typeof({innerValueTypeName}), options);");
                cw.AppendLine("return From(innerValue);");
            }

            cw.AppendLine($"public override void WriteAsPropertyName(global::System.Text.Json.Utf8JsonWriter writer, {valueObjectTypeName} value, global::System.Text.Json.JsonSerializerOptions options)");
            using (cw.AddBlock())
            {
                cw.AppendLine("var innerValueConverter = GetInnerValueConverter(options);");
                cw.AppendLine("innerValueConverter.WriteAsPropertyName(writer, value.Value, options);");
            }
        }
    }

    public static void AddEfCoreClasses(CodeWriter cw, string valueObjectTypeName, string innerValueTypeName)
    {
        cw.AppendLine($"public class EfCoreValueConverter : global::Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter<{valueObjectTypeName}, {innerValueTypeName}>");
        using (cw.AddBlock())
        {
            cw.AppendLine("public EfCoreValueConverter() : this(null) { }");
            cw.AppendLine("public EfCoreValueConverter(global::Microsoft.EntityFrameworkCore.Storage.ValueConversion.ConverterMappingHints? mappingHints = null) : base(");
            cw.AppendLine("\tvalue => value.Value,");
            cw.AppendLine("\tinnerValue => From(innerValue), mappingHints) { }");
        }

        cw.AppendLine($"public class EfCoreValueComparer : global::Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer<{valueObjectTypeName}>");
        using (cw.AddBlock())
        {
            cw.AppendLine("public EfCoreValueComparer() : base((left, right) => right.Equals(left), value => value.GetHashCode(), value => From(value.Value)) { }");
            cw.AppendLine($"public override int GetHashCode({valueObjectTypeName} value) => value.GetHashCode();");
            cw.AppendLine($"public override bool Equals({valueObjectTypeName} left, {valueObjectTypeName} right) => right.Equals(left);");
        }
    }

    public static void AddEfCoreExtensions(CodeWriter cw, string valueObjectTypeName, string accessibility)
    {
        cw.AppendLine($"{accessibility} static class {valueObjectTypeName}EfCoreExtensions");
        using (cw.AddBlock())
        {
            cw.AppendLine($"public static global::Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder<{valueObjectTypeName}> HasTransparentValueObjectConversion(this global::Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder<{valueObjectTypeName}> propertyBuilder) =>");
            cw.AppendLine($"propertyBuilder.HasConversion<{valueObjectTypeName}.EfCoreValueConverter, {valueObjectTypeName}.EfCoreValueComparer>();");
        }
    }

    private readonly struct Target : IEquatable<Target>
    {
        public readonly StructDeclarationSyntax Syntax;
        public readonly AttributeData AttributeData;

        public Target(StructDeclarationSyntax syntax, AttributeData attributeData)
        {
            Syntax = syntax;
            AttributeData = attributeData;
        }

        public bool Equals(Target other)
        {
            return Syntax.Equals(other.Syntax) && AttributeData.Equals(other.AttributeData);
        }

        public override bool Equals(object? obj)
        {
            return obj is Target other && Equals(other);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return (Syntax.GetHashCode() * 397) ^ AttributeData.GetHashCode();
            }
        }
    }
}
